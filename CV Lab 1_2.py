# -*- coding: utf-8 -*-
"""CV_Lab 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1m4OxghCv3jgCGy63wUbXPuGkW83h-i0O
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
import math

sample = "/content/drive/MyDrive/Labs/Computer Vision/NBA Hoop.webp"

img = cv2.imread(sample)

plt.imshow(img)
plt.show()

#Generating random Image

img1 = np.random.randint(222, size=(100, 100, 3))
genimg = np.array(img1, dtype = np.uint8)

plt.imshow(genimg)

plt.show()

B = [[0,1], [0,1]]
C = [[1,0], [1,0]]

plt.imshow(B, cmap='gray')
plt.show()

plt.imshow(C, cmap='gray')
plt.show()

D = [[0,0,0,0,0],
     [0,0,0,0,1],
     [0,0,0,1,1],
     [0,0,1,1,1],
     [0,1,1,1,1],
     [1,1,1,1,1]]

plt.imshow(D, cmap='gray')
plt.show()

chess = np.array([[1,0,1,0,1,0,1,0],
                  [0,1,0,1,0,1,0,1],
                  [1,0,1,0,1,0,1,0],
                  [0,1,0,1,0,1,0,1],
                  [1,0,1,0,1,0,1,0],
                  [0,1,0,1,0,1,0,1],
                  [1,0,1,0,1,0,1,0],
                  [0,1,0,1,0,1,0,1]])
plt.imshow(chess, cmap='gray')

blank = np.zeros((1000,1000,3), dtype = "uint8")

points = np.array([[0, 0], [0, 1000], [1000, 0]])

cv2.fillPoly(blank, pts = [points], color = (255, 255, 255))

plt.imshow(blank)

plt.show()

#Distances in Python

def cityblock(p1, p2):
    return (abs(p1[0]-p2[0]) + abs(p1[1] - p2[1]))

def chessboard(p1, p2):
    return max(abs(p1[0]-p2[0]), abs(p1[1] - p2[1]))

def euclidean(p1, p2):
    return (math.sqrt((p1[0]-p2[0])**2 + abs(p1[1] - p2[1])**2))

f, ax = plt.subplots(1,3,figsize=(10,3))
for a in ax:
    a.set_xlim(0, 200)
    a.set_ylim(0, 200)

x,y = 100,100
D = 50
points = []

for i in range(-D, D + 1):
    for j in range(-D, D + 1):
        if euclidean((x, y), (x + i, y + j)) <= D:
            points.append((x + i, y + j))
ax[0].scatter([p[0] for p in points], [p[1] for p in points])
ax[0].set_title("Euclidean Distance Pattern")

points = []
for i in range(-D, D + 1):
    for j in range(-D, D + 1):
        if chessboard((x, y), (x + i, y + j)) <= D:
            points.append((x + i, y + j))
ax[1].scatter([p[0] for p in points], [p[1] for p in points])
ax[1].set_title("Chessboard Distance Pattern")

points = []
for i in range(-D, D + 1):
    for j in range(-D, D + 1):
        if cityblock((x, y), (x + i, y + j)) <= D:
            points.append((x + i, y + j))
ax[2].scatter([p[0] for p in points], [p[1] for p in points])
ax[2].set_title("Cityblock Distance Pattern")

plt.show()